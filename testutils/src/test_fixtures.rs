//! Test fixtures for running client RPC tests from external crates
//!
//! For validator/indexer development, the struct must be added to this crate (validator.rs / indexer.rs)
//! and the test fixtures must be expanded to include the additional process
//!
//! If running test fixtures from an external crate, the chain cache should be generated by running
//! `generate_chain_cache` which will cache the chain in a `CARGO_MANIFEST_DIR/chain_cache/client_rpcs` directory
//!
//! ```ignore(incomplete)
//! #[ignore = "not a test. generates chain cache for client_rpc tests."]
//! #[tokio::test]
//! async fn generate_zcashd_chain_cache() {
//!   zcash_local_net::test_fixtures::generate_zcashd_chain_cache(
//!     None,
//!     None,
//!     None,
//!   )
//!   .await;
//! }
//! ```

use std::{path::PathBuf, sync::Arc};

use tokio::sync::mpsc::unbounded_channel;
use zcash_client_backend::proto;
use zcash_primitives::transaction::Transaction;
use zcash_protocol::{
    consensus::{BlockHeight, BranchId},
    PoolType, ShieldedProtocol,
};
use zingolib::{
    config::{ChainType, RegtestNetwork},
    lightclient::LightClient,
    testutils::lightclient::{from_inputs, get_base_address},
    testvectors::REG_O_ADDR_FROM_ABANDONART,
    wallet::data::summaries::TransactionSummaryInterface,
};

use crate::client;

use zingo_infra_services::{
    config,
    indexer::{Indexer as _, Lightwalletd, LightwalletdConfig, Zainod, ZainodConfig},
    network::{self, Network},
    utils,
    validator::{Validator as _, Zcashd, ZcashdConfig, Zebrad, ZebradConfig, ZEBRAD_DEFAULT_MINER},
    LocalNet,
};
/// Generates zebrad chain cache for client RPC test fixtures requiring a large chain
pub async fn generate_zebrad_large_chain_cache(
    zebrad_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let mut local_net = LocalNet::<Lightwalletd, Zebrad>::launch(
        LightwalletdConfig {
            lightwalletd_bin,
            listen_port: None,
            zcashd_conf: PathBuf::new(),
        },
        ZebradConfig {
            zebrad_bin,
            network_listen_port: None,
            rpc_listen_port: None,
            activation_heights: network::ActivationHeights::default(),
            miner_address: ZEBRAD_DEFAULT_MINER,
            chain_cache: None,
            network: Network::Regtest,
        },
    )
    .await;

    local_net.validator().generate_blocks(150).await.unwrap();

    let chain_cache_dir = utils::chain_cache_dir();
    if !chain_cache_dir.exists() {
        std::fs::create_dir_all(chain_cache_dir.clone()).unwrap();
    }
    local_net
        .validator_mut()
        .cache_chain(chain_cache_dir.join("client_rpc_tests_large"));
}

/// Generates zcashd chain cache for client RPC test fixtures
pub async fn generate_zcashd_chain_cache(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let mut local_net = LocalNet::<Lightwalletd, Zcashd>::launch(
        LightwalletdConfig {
            lightwalletd_bin,
            listen_port: None,
            zcashd_conf: PathBuf::new(),
        },
        ZcashdConfig {
            zcashd_bin,
            zcash_cli_bin,
            rpc_listen_port: None,
            activation_heights: network::ActivationHeights::default(),
            miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
            chain_cache: None,
        },
    )
    .await;

    local_net.validator().generate_blocks(2).await.unwrap();

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) = client::build_lightclients(
        lightclient_dir.path().to_path_buf(),
        local_net.indexer().port(),
    )
    .await;

    // TODO: use second recipient taddr
    // recipient.do_new_address("ozt").await.unwrap();
    // let recipient_addresses = recipient.do_addresses().await;
    // recipient taddr child index 0:
    // tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i
    //
    // recipient taddr child index 1:
    // tmAtLC3JkTDrXyn5okUbb6qcMGE4Xq4UdhD
    //
    // faucet taddr child index 0:
    // tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            100_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Transparent).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    recipient.do_sync(false).await.unwrap();
    recipient.quick_shield().await.unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Transparent).await,
            200_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    recipient.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Transparent).await,
            10_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    recipient.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            10_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(2).await.unwrap();

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    let chain_cache_dir = utils::chain_cache_dir();
    if !chain_cache_dir.exists() {
        std::fs::create_dir_all(chain_cache_dir.clone()).unwrap();
    }
    local_net
        .validator_mut()
        .cache_chain(chain_cache_dir.join("client_rpc_tests"));
}

/// GetLightdInfo RPC test
pub async fn get_lightd_info(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let zainod_response = zainod_client
        .get_lightd_info(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let lwd_response = lwd_client
        .get_lightd_info(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetLightdInfo responses...");

    println!("\nZainod response:");
    println!("taddr support: {}", zainod_response.taddr_support);
    println!("chain name: {}", zainod_response.chain_name);
    println!(
        "sapling activation height: {}",
        zainod_response.sapling_activation_height
    );
    println!(
        "consensus branch id: {}",
        zainod_response.consensus_branch_id
    );
    println!("block height: {}", zainod_response.block_height);
    println!("estimated height: {}", zainod_response.estimated_height);
    println!("zcashd build: {}", zainod_response.zcashd_build);
    println!("zcashd subversion: {}", zainod_response.zcashd_subversion);

    println!("\nLightwalletd response:");
    println!("taddr support: {}", lwd_response.taddr_support);
    println!("chain name: {}", lwd_response.chain_name);
    println!(
        "sapling activation height: {}",
        lwd_response.sapling_activation_height
    );
    println!("consensus branch id: {}", lwd_response.consensus_branch_id);
    println!("block height: {}", lwd_response.block_height);
    println!("estimated height: {}", lwd_response.estimated_height);
    println!("zcashd build: {}", lwd_response.zcashd_build);
    println!("zcashd subversion: {}", lwd_response.zcashd_subversion);

    println!();
    println!();

    assert_eq!(zainod_response.taddr_support, lwd_response.taddr_support);
    assert_eq!(zainod_response.chain_name, lwd_response.chain_name);
    assert_eq!(
        zainod_response.sapling_activation_height,
        lwd_response.sapling_activation_height
    );
    assert_eq!(
        zainod_response.consensus_branch_id,
        lwd_response.consensus_branch_id
    );
    assert_eq!(zainod_response.block_height, lwd_response.block_height);
    assert_eq!(
        zainod_response.estimated_height,
        lwd_response.estimated_height
    );
    assert_eq!(zainod_response.zcashd_build, lwd_response.zcashd_build);
    assert_eq!(
        zainod_response.zcashd_subversion,
        lwd_response.zcashd_subversion
    );
}

/// GetLatestBlock RPC test
pub async fn get_latest_block(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::ChainSpec {});
    let zainod_response = zainod_client
        .get_latest_block(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::ChainSpec {});
    let lwd_response = lwd_client
        .get_latest_block(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetLatestBlock responses...");

    println!("\nZainod response:");
    println!("block id: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("block id: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetBlock RPC test
pub async fn get_block(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 5,
        hash: vec![],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_response = zainod_client.get_block(request).await.unwrap().into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let lwd_response = lwd_client.get_block(request).await.unwrap().into_inner();

    println!("Asserting GetBlock responses...");

    println!("\nZainod response:");
    println!("compact block: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("compact block: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetBlock RPC test
pub async fn get_block_out_of_bounds(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 20,
        hash: vec![],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_err_status = zainod_client.get_block(request).await.unwrap_err();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let lwd_err_status = lwd_client.get_block(request).await.unwrap_err();

    println!("Asserting GetBlock responses...");

    println!("\nZainod response:");
    println!("error status: {:?}", zainod_err_status);

    println!("\nLightwalletd response:");
    println!("error status: {:?}", lwd_err_status);

    println!();

    assert_eq!(zainod_err_status.code(), lwd_err_status.code());
    assert_eq!(zainod_err_status.message(), lwd_err_status.message());
}

/// GetBlockNullifiers RPC test
pub async fn get_block_nullifiers(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 5,
        hash: vec![],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_response = zainod_client
        .get_block_nullifiers(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let lwd_response = lwd_client
        .get_block_nullifiers(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetBlockNullifiers responses...");

    println!("\nZainod response:");
    println!("compact block: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("compact block: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetBlockRangeNullifiers RPC test
pub async fn get_block_range_nullifiers(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 1,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 6,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range_nullifiers(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    while let Some(compact_block) = zainod_response.message().await.unwrap() {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range_nullifiers(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    while let Some(compact_block) = lwd_response.message().await.unwrap() {
        lwd_blocks.push(compact_block);
    }

    println!("Asserting GetBlockRangeNullifiers responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
}

/// GetBlockRangeNullifiers RPC test
pub async fn get_block_range_nullifiers_reverse(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 10,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 4,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range_nullifiers(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    while let Some(compact_block) = zainod_response.message().await.unwrap() {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range_nullifiers(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    while let Some(compact_block) = lwd_response.message().await.unwrap() {
        lwd_blocks.push(compact_block);
    }

    println!("Asserting GetBlockRangeNullifiers responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
}

/// GetBlockRange RPC test
pub async fn get_block_range_lower(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 1,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 6,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    while let Some(compact_block) = zainod_response.message().await.unwrap() {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    while let Some(compact_block) = lwd_response.message().await.unwrap() {
        lwd_blocks.push(compact_block);
    }

    println!("Asserting GetBlockRange responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
}

/// GetBlockRange RPC test
pub async fn get_block_range_upper(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 4,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 10,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    while let Some(compact_block) = zainod_response.message().await.unwrap() {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    while let Some(compact_block) = lwd_response.message().await.unwrap() {
        lwd_blocks.push(compact_block);
    }

    println!("Asserting GetBlockRange responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
}

/// GetBlockRange RPC test
pub async fn get_block_range_reverse(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 10,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 1,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    while let Some(compact_block) = zainod_response.message().await.unwrap() {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    while let Some(compact_block) = lwd_response.message().await.unwrap() {
        lwd_blocks.push(compact_block);
    }

    println!("Asserting GetBlockRange responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
}

/// GetBlockRange RPC test
pub async fn get_block_range_out_of_bounds(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 4,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 20,
            hash: vec![],
        }),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut zainod_response = zainod_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_blocks = Vec::new();
    let mut zainod_err_status = None;
    while let Some(compact_block) = match zainod_response.message().await {
        Ok(message) => message,
        Err(e) => {
            zainod_err_status = Some(e);
            None
        }
    } {
        zainod_blocks.push(compact_block);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_range.clone());
    let mut lwd_response = lwd_client
        .get_block_range(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_blocks = Vec::new();
    let mut lwd_err_status = None;
    while let Some(compact_block) = match lwd_response.message().await {
        Ok(message) => message,
        Err(e) => {
            lwd_err_status = Some(e);
            None
        }
    } {
        lwd_blocks.push(compact_block);
    }

    let lwd_err_status = lwd_err_status.unwrap();
    let zainod_err_status = zainod_err_status.unwrap();

    println!("Asserting GetBlockRange responses...");

    println!("\nZainod response:");
    println!("compact blocks: {:?}", zainod_blocks);
    println!("error status: {:?}", zainod_err_status);

    println!("\nLightwalletd response:");
    println!("compact blocks: {:?}", lwd_blocks);
    println!("error status: {:?}", lwd_err_status);

    println!();

    assert_eq!(zainod_blocks, lwd_blocks);
    assert_eq!(
        zainod_err_status.message(),
        "Error: Height out of range [20]. Height requested is greater than the best chain tip [10].");
    assert_eq!(lwd_err_status.message(), "-8: Block height out of range");
    assert_eq!(zainod_err_status.code(), tonic::Code::OutOfRange);
    assert_eq!(lwd_err_status.code(), tonic::Code::Unknown);
}

/// GetTransaction RPC test
pub async fn get_transaction(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    // TODO: get txid from chain cache
    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;
    faucet.do_sync(false).await.unwrap();
    let txids = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    zcashd.generate_blocks(1).await.unwrap();

    let tx_filter = proto::service::TxFilter {
        block: None,
        index: 0,
        hash: txids.first().as_ref().to_vec(),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(tx_filter.clone());
    let zainod_response = zainod_client
        .get_transaction(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(tx_filter.clone());
    let lwd_response = lwd_client
        .get_transaction(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetTransaction responses...");

    println!("\nZainod response:");
    println!("raw transaction: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("raw transaction: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// SendTransaction RPC test
///
/// INCOMPLETE
pub async fn send_transaction(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    _lightwalletd_bin: Option<PathBuf>,
) {
    let local_net = LocalNet::<Zainod, Zcashd>::launch(
        ZainodConfig {
            zainod_bin: zainod_bin.clone(),
            listen_port: None,
            validator_port: 0,
            network: network::Network::Regtest,
        },
        ZcashdConfig {
            zcashd_bin: zcashd_bin.clone(),
            zcash_cli_bin: zcash_cli_bin.clone(),
            rpc_listen_port: None,
            activation_heights: network::ActivationHeights::default(),
            miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
            chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
        },
    )
    .await;

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) = client::build_lightclients(
        lightclient_dir.path().to_path_buf(),
        local_net.indexer().port(),
    )
    .await;
    faucet.do_sync(false).await.unwrap();
    let txids = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    let tx_filter = proto::service::TxFilter {
        block: None,
        index: 0,
        hash: txids.first().as_ref().to_vec(),
    };

    let mut zainod_client =
        client::build_client(network::localhost_uri(local_net.indexer().port()))
            .await
            .unwrap();
    let request = tonic::Request::new(tx_filter.clone());
    let zainod_response = zainod_client
        .get_transaction(request)
        .await
        .unwrap()
        .into_inner();

    drop(local_net);

    let local_net = LocalNet::<Zainod, Zcashd>::launch(
        ZainodConfig {
            zainod_bin,
            listen_port: None,
            validator_port: 0,
            network: network::Network::Regtest,
        },
        ZcashdConfig {
            zcashd_bin,
            zcash_cli_bin,
            rpc_listen_port: None,
            activation_heights: network::ActivationHeights::default(),
            miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
            chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
        },
    )
    .await;

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) = client::build_lightclients(
        lightclient_dir.path().to_path_buf(),
        local_net.indexer().port(),
    )
    .await;
    faucet.do_sync(false).await.unwrap();
    let txids = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).await.unwrap();

    let tx_filter = proto::service::TxFilter {
        block: None,
        index: 0,
        hash: txids.first().as_ref().to_vec(),
    };

    let mut zainod_client =
        client::build_client(network::localhost_uri(local_net.indexer().port()))
            .await
            .unwrap();
    let request = tonic::Request::new(tx_filter.clone());
    let lwd_response = zainod_client
        .get_transaction(request)
        .await
        .unwrap()
        .into_inner();

    let chain_type = ChainType::Regtest(RegtestNetwork::all_upgrades_active());
    let zainod_tx = Transaction::read(
        &zainod_response.data[..],
        BranchId::for_height(
            &chain_type,
            BlockHeight::from_u32(zainod_response.height as u32),
        ),
    )
    .unwrap();
    let lwd_tx = Transaction::read(
        &lwd_response.data[..],
        BranchId::for_height(
            &chain_type,
            BlockHeight::from_u32(lwd_response.height as u32),
        ),
    )
    .unwrap();

    println!("Asserting transactions sent using SendTransacton...");

    println!("\nZainod:");
    println!("transaction: {:?}", zainod_tx);

    println!("\nLightwalletd:");
    println!("transaction: {:?}", lwd_tx);

    println!();

    assert_eq!(zainod_tx, lwd_tx);
}

/// GetTaddressTxids RPC test
pub async fn get_taddress_txids_all(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let chain_type = ChainType::Regtest(RegtestNetwork::all_upgrades_active());

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 1,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 10,
            hash: vec![],
        }),
    };

    let taddr_block_filter = proto::service::TransparentAddressBlockFilter {
        address: "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
        range: Some(block_range),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut zainod_response = zainod_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_raw_txs = Vec::new();
    while let Some(raw_tx) = zainod_response.message().await.unwrap() {
        zainod_raw_txs.push(raw_tx);
    }
    let mut zainod_txs = zainod_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    zainod_txs.sort_by_key(|a| a.txid());

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut lwd_response = lwd_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_raw_txs = Vec::new();
    while let Some(raw_tx) = lwd_response.message().await.unwrap() {
        lwd_raw_txs.push(raw_tx);
    }
    let mut lwd_txs = lwd_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    lwd_txs.sort_by_key(|a| a.txid());

    println!("Asserting GetTaddressTxids responses...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    assert_eq!(lwd_txs.len(), 3);
    assert_eq!(zainod_raw_txs, lwd_raw_txs);
}

/// GetTaddressTxids RPC test
pub async fn get_taddress_txids_lower(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let chain_type = ChainType::Regtest(RegtestNetwork::all_upgrades_active());

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 1,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 4,
            hash: vec![],
        }),
    };

    let taddr_block_filter = proto::service::TransparentAddressBlockFilter {
        address: "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
        range: Some(block_range),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut zainod_response = zainod_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_raw_txs = Vec::new();
    while let Some(raw_tx) = zainod_response.message().await.unwrap() {
        zainod_raw_txs.push(raw_tx);
    }
    let mut zainod_txs = zainod_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    zainod_txs.sort_by_key(|a| a.txid());

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut lwd_response = lwd_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_raw_txs = Vec::new();
    while let Some(raw_tx) = lwd_response.message().await.unwrap() {
        lwd_raw_txs.push(raw_tx);
    }
    let mut lwd_txs = lwd_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    lwd_txs.sort_by_key(|a| a.txid());

    println!("Asserting GetTaddressTxids responses...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    assert_eq!(lwd_txs.len(), 1);
    assert_eq!(zainod_raw_txs, lwd_raw_txs);
}

/// GetTaddressTxids RPC test
pub async fn get_taddress_txids_upper(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let chain_type = ChainType::Regtest(RegtestNetwork::all_upgrades_active());

    let block_range = proto::service::BlockRange {
        start: Some(proto::service::BlockId {
            height: 5,
            hash: vec![],
        }),
        end: Some(proto::service::BlockId {
            height: 10,
            hash: vec![],
        }),
    };

    let taddr_block_filter = proto::service::TransparentAddressBlockFilter {
        address: "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
        range: Some(block_range),
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut zainod_response = zainod_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_raw_txs = Vec::new();
    while let Some(raw_tx) = zainod_response.message().await.unwrap() {
        zainod_raw_txs.push(raw_tx);
    }
    let mut zainod_txs = zainod_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    zainod_txs.sort_by_key(|a| a.txid());

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(taddr_block_filter.clone());
    let mut lwd_response = lwd_client
        .get_taddress_txids(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_raw_txs = Vec::new();
    while let Some(raw_tx) = lwd_response.message().await.unwrap() {
        lwd_raw_txs.push(raw_tx);
    }
    let mut lwd_txs = lwd_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    lwd_txs.sort_by_key(|a| a.txid());

    println!("Asserting GetTaddressTxids responses...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    assert_eq!(lwd_txs.len(), 2);
    assert_eq!(zainod_raw_txs, lwd_raw_txs);
}

/// GetTaddressBalance RPC test
pub async fn get_taddress_balance(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_list = proto::service::AddressList {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_list.clone());
    let zainod_response = zainod_client
        .get_taddress_balance(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_list.clone());
    let lwd_response = lwd_client
        .get_taddress_balance(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetTaddressBalance responses...");

    println!("\nZainod response:");
    println!("balance: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("balance: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response.value_zat, 210_000i64);
    assert_eq!(zainod_response, lwd_response);
}

/// GetTaddressBalanceStream RPC test
pub async fn get_taddress_balance_stream(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_list = vec![
        proto::service::Address {
            address: "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
        },
        proto::service::Address {
            address: "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        },
    ];

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(tokio_stream::iter(address_list.clone()));
    let zainod_response = zainod_client
        .get_taddress_balance_stream(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(tokio_stream::iter(address_list.clone()));
    let lwd_response = lwd_client
        .get_taddress_balance_stream(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetTaddressBalanceStream responses...");

    println!("\nZainod response:");
    println!("balance: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("balance: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response.value_zat, 210_000i64);
    assert_eq!(zainod_response, lwd_response);
}

/// GetMempoolTx RPC test
pub async fn get_mempool_tx(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;

    faucet.do_sync(false).await.unwrap();
    let txids_1 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            200_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    let txids_2 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();

    recipient.do_sync(false).await.unwrap();
    let txids_3 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            50_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    let txids_4 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            25_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;

    let full_txid_2 = txids_2.first().as_ref().to_vec();
    // the excluded list only accepts truncated txids when they are truncated at the start, not end.
    let mut full_txid_4 = txids_4.first().as_ref().to_vec();
    let truncated_txid_4 = full_txid_4.drain(16..).collect();

    let exclude_list = proto::service::Exclude {
        txid: vec![full_txid_2, truncated_txid_4],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(exclude_list.clone());
    let mut zainod_response = zainod_client
        .get_mempool_tx(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_txs = Vec::new();
    while let Some(compact_tx) = zainod_response.message().await.unwrap() {
        zainod_txs.push(compact_tx);
    }
    zainod_txs.sort_by(|a, b| a.hash.cmp(&b.hash));

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(exclude_list.clone());
    let mut lwd_response = lwd_client
        .get_mempool_tx(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_txs = Vec::new();
    while let Some(compact_tx) = lwd_response.message().await.unwrap() {
        lwd_txs.push(compact_tx);
    }
    lwd_txs.sort_by(|a, b| a.hash.cmp(&b.hash));

    println!("Asserting GetMempoolTx responses...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    // the response txid is the reverse of the txid returned from quick send
    let mut txid_1_rev = txids_1.first().as_ref().to_vec();
    txid_1_rev.reverse();
    let mut txid_3_rev = txids_3.first().as_ref().to_vec();
    txid_3_rev.reverse();
    let mut txids = [txid_1_rev, txid_3_rev];
    txids.sort();

    assert_eq!(lwd_txs.len(), 2);
    assert_eq!(lwd_txs[0].hash, txids[0]);
    assert_eq!(lwd_txs[1].hash, txids[1]);
    assert_eq!(zainod_txs, lwd_txs);
}

/// GetMempoolStream RPC test (zingolib mempool monitor)
pub async fn get_mempool_stream_zingolib_mempool_monitor(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;

    faucet.do_sync(false).await.unwrap();
    let _txids_1 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            200_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    let _txids_2 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();

    recipient.do_sync(false).await.unwrap();
    let _txids_3 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            50_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    let _txids_4 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            25_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;

    drop(recipient);
    drop(faucet);

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (_faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), zainod.port()).await;

    let recipient = Arc::new(recipient);
    recipient.do_sync(false).await.unwrap();
    LightClient::start_mempool_monitor(recipient.clone()).unwrap();
    recipient.do_sync(false).await.unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    let zainod_tx_summaries = recipient.detailed_transaction_summaries().await;
    println!("Zainod Transactions:\n{}", zainod_tx_summaries);
    let mut zainod_tx_summaries = zainod_tx_summaries.0;

    drop(recipient);
    drop(_faucet);

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (_faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;

    let recipient = Arc::new(recipient);
    recipient.do_sync(false).await.unwrap();
    LightClient::start_mempool_monitor(recipient.clone()).unwrap();
    recipient.do_sync(false).await.unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    let lwd_tx_summaries = recipient.detailed_transaction_summaries().await;
    println!("Lightwalletd Transactions:\n{}", lwd_tx_summaries);
    let mut lwd_tx_summaries = lwd_tx_summaries.0;

    zainod_tx_summaries.sort_by_key(|tx| tx.txid());
    zainod_tx_summaries.sort_by_key(|tx| tx.blockheight());
    lwd_tx_summaries.sort_by_key(|tx| tx.txid());
    lwd_tx_summaries.sort_by_key(|tx| tx.blockheight());

    println!("Asserting wallet transaction summaries...");

    assert_eq!(lwd_tx_summaries.len(), zainod_tx_summaries.len());

    for i in 0..zainod_tx_summaries.len() {
        println!("\nZainod transaction {}:", i);
        println!("{}", zainod_tx_summaries[i]);

        println!("\nLightwalletd transaction {}:", i);
        println!("{}", lwd_tx_summaries[i]);

        println!();

        assert_eq!(lwd_tx_summaries[i].txid(), zainod_tx_summaries[i].txid());
        assert_eq!(
            lwd_tx_summaries[i].status(),
            zainod_tx_summaries[i].status()
        );
        assert_eq!(
            lwd_tx_summaries[i].blockheight(),
            zainod_tx_summaries[i].blockheight()
        );
        assert_eq!(lwd_tx_summaries[i].kind(), zainod_tx_summaries[i].kind());
        assert_eq!(lwd_tx_summaries[i].value(), zainod_tx_summaries[i].value());
        assert_eq!(lwd_tx_summaries[i].fee(), zainod_tx_summaries[i].fee());
        assert_eq!(
            lwd_tx_summaries[i].zec_price(),
            zainod_tx_summaries[i].zec_price()
        );
        assert_eq!(
            lwd_tx_summaries[i].orchard_notes(),
            zainod_tx_summaries[i].orchard_notes()
        );
        assert_eq!(
            lwd_tx_summaries[i].sapling_notes(),
            zainod_tx_summaries[i].sapling_notes()
        );
        assert_eq!(
            lwd_tx_summaries[i].transparent_coins(),
            zainod_tx_summaries[i].transparent_coins()
        );
        assert_eq!(
            lwd_tx_summaries[i].outgoing_tx_data(),
            zainod_tx_summaries[i].outgoing_tx_data()
        );
        assert_eq!(
            lwd_tx_summaries[i].orchard_nullifiers(),
            zainod_tx_summaries[i].orchard_nullifiers()
        );
        assert_eq!(
            lwd_tx_summaries[i].sapling_nullifiers(),
            zainod_tx_summaries[i].sapling_nullifiers()
        );
    }
}

/// GetMempoolStream RPC test
pub async fn get_mempool_stream(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    // start mempool tasks
    let (zainod_sender, mut zainod_receiver) =
        unbounded_channel::<proto::service::RawTransaction>();
    let zainod_port = zainod.port();
    let _zainod_handle = tokio::spawn(async move {
        let mut zainod_client = client::build_client(network::localhost_uri(zainod_port))
            .await
            .unwrap();
        loop {
            let request = tonic::Request::new(proto::service::Empty {});
            let mut zainod_response = zainod_client
                .get_mempool_stream(request)
                .await
                .unwrap()
                .into_inner();
            while let Some(raw_tx) = zainod_response.message().await.unwrap() {
                zainod_sender.send(raw_tx).unwrap();
            }
            tokio::time::sleep(std::time::Duration::from_secs(3)).await;
        }
    });

    let (lwd_sender, mut lwd_receiver) = unbounded_channel::<proto::service::RawTransaction>();
    let lwd_port = lightwalletd.port();
    let _lwd_handle = tokio::spawn(async move {
        let mut lwd_client = client::build_client(network::localhost_uri(lwd_port))
            .await
            .unwrap();
        loop {
            let request = tonic::Request::new(proto::service::Empty {});
            let mut lwd_response = lwd_client
                .get_mempool_stream(request)
                .await
                .unwrap()
                .into_inner();
            while let Some(raw_tx) = lwd_response.message().await.unwrap() {
                lwd_sender.send(raw_tx).unwrap();
            }
            tokio::time::sleep(std::time::Duration::from_secs(3)).await;
        }
    });

    // send txs to mempool
    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;

    faucet.do_sync(false).await.unwrap();
    let txids_1 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            200_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    let txids_2 = from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();

    // receive txs from mempool
    let chain_type = ChainType::Regtest(RegtestNetwork::all_upgrades_active());

    let mut zainod_raw_txs = Vec::new();
    while let Some(raw_tx) = zainod_receiver.recv().await {
        zainod_raw_txs.push(raw_tx);
        if zainod_raw_txs.len() == 2 {
            break;
        }
    }
    let mut zainod_txs = zainod_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    zainod_txs.sort_by_key(|a| a.txid());

    let mut lwd_raw_txs = Vec::new();
    while let Some(raw_tx) = lwd_receiver.recv().await {
        lwd_raw_txs.push(raw_tx);
        if lwd_raw_txs.len() == 2 {
            break;
        }
    }
    let mut lwd_txs = lwd_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    lwd_txs.sort_by_key(|a| a.txid());

    println!("Asserting GetMempoolStream responses...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    let mut txids = vec![txids_1.first(), txids_2.first()];
    txids.sort();

    assert_eq!(lwd_txs.len(), 2);
    assert_eq!(&lwd_txs[0].txid(), txids[0]);
    assert_eq!(&lwd_txs[1].txid(), txids[1]);
    assert_eq!(zainod_txs, lwd_txs);

    // send more txs to mempool
    recipient.do_sync(false).await.unwrap();
    let txids_3 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            50_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    // TODO: add generate block here to test next block behaviour
    let txids_4 = from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            25_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();

    // receive txs from mempool
    while let Some(raw_tx) = zainod_receiver.recv().await {
        zainod_raw_txs.push(raw_tx);
        if zainod_raw_txs.len() == 4 {
            break;
        }
    }
    let mut zainod_txs = zainod_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    zainod_txs.sort_by_key(|a| a.txid());

    while let Some(raw_tx) = lwd_receiver.recv().await {
        lwd_raw_txs.push(raw_tx);
        if lwd_raw_txs.len() == 4 {
            break;
        }
    }
    let mut lwd_txs = lwd_raw_txs
        .iter()
        .map(|raw_tx| {
            Transaction::read(
                &raw_tx.data[..],
                BranchId::for_height(&chain_type, BlockHeight::from_u32(raw_tx.height as u32)),
            )
            .unwrap()
        })
        .collect::<Vec<_>>();
    lwd_txs.sort_by_key(|a| a.txid());

    println!("Asserting GetMempoolStream responses (pt2)...");

    println!("\nZainod response:");
    println!("transactions: {:?}", zainod_txs);

    println!("\nLightwalletd response:");
    println!("transactions: {:?}", lwd_txs);

    println!();

    txids.push(txids_3.first());
    txids.push(txids_4.first());
    txids.sort();

    assert_eq!(lwd_txs.len(), 4);
    assert_eq!(&lwd_txs[0].txid(), txids[0]);
    assert_eq!(&lwd_txs[1].txid(), txids[1]);
    assert_eq!(&lwd_txs[2].txid(), txids[2]);
    assert_eq!(&lwd_txs[3].txid(), txids[3]);
    assert_eq!(zainod_txs, lwd_txs);

    drop(recipient);
    drop(faucet);

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (_faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), zainod.port()).await;

    let recipient = Arc::new(recipient);
    LightClient::start_mempool_monitor(recipient.clone()).unwrap();
    recipient.do_sync(false).await.unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    let zainod_tx_summaries = recipient.detailed_transaction_summaries().await;
    println!("Zainod Transactions:\n{}\n", zainod_tx_summaries);
    let mut zainod_tx_summaries = zainod_tx_summaries.0;

    drop(recipient);
    drop(_faucet);

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (_faucet, recipient) =
        client::build_lightclients(lightclient_dir.path().to_path_buf(), lightwalletd.port()).await;

    let recipient = Arc::new(recipient);
    LightClient::start_mempool_monitor(recipient.clone()).unwrap();
    recipient.do_sync(false).await.unwrap();
    tokio::time::sleep(std::time::Duration::from_secs(5)).await;
    let lwd_tx_summaries = recipient.detailed_transaction_summaries().await;
    println!("Lightwalletd Transactions:\n{}\n", lwd_tx_summaries);
    let mut lwd_tx_summaries = lwd_tx_summaries.0;

    zainod_tx_summaries.sort_by_key(|tx| tx.txid());
    zainod_tx_summaries.sort_by_key(|tx| tx.blockheight());
    lwd_tx_summaries.sort_by_key(|tx| tx.txid());
    lwd_tx_summaries.sort_by_key(|tx| tx.blockheight());

    println!("Asserting wallet transaction summaries...");

    assert_eq!(lwd_tx_summaries.len(), zainod_tx_summaries.len());

    for i in 0..zainod_tx_summaries.len() {
        println!("\nZainod transaction {}:", i);
        println!("{}", zainod_tx_summaries[i]);

        println!("\nLightwalletd transaction {}:", i);
        println!("{}", lwd_tx_summaries[i]);

        println!();

        assert_eq!(lwd_tx_summaries[i].txid(), zainod_tx_summaries[i].txid());
        assert_eq!(
            lwd_tx_summaries[i].status(),
            zainod_tx_summaries[i].status()
        );
        assert_eq!(
            lwd_tx_summaries[i].blockheight(),
            zainod_tx_summaries[i].blockheight()
        );
        assert_eq!(lwd_tx_summaries[i].kind(), zainod_tx_summaries[i].kind());
        assert_eq!(lwd_tx_summaries[i].value(), zainod_tx_summaries[i].value());
        assert_eq!(lwd_tx_summaries[i].fee(), zainod_tx_summaries[i].fee());
        assert_eq!(
            lwd_tx_summaries[i].zec_price(),
            zainod_tx_summaries[i].zec_price()
        );
        assert_eq!(
            lwd_tx_summaries[i].orchard_notes(),
            zainod_tx_summaries[i].orchard_notes()
        );
        assert_eq!(
            lwd_tx_summaries[i].sapling_notes(),
            zainod_tx_summaries[i].sapling_notes()
        );
        assert_eq!(
            lwd_tx_summaries[i].transparent_coins(),
            zainod_tx_summaries[i].transparent_coins()
        );
        assert_eq!(
            lwd_tx_summaries[i].outgoing_tx_data(),
            zainod_tx_summaries[i].outgoing_tx_data()
        );
        assert_eq!(
            lwd_tx_summaries[i].orchard_nullifiers(),
            zainod_tx_summaries[i].orchard_nullifiers()
        );
        assert_eq!(
            lwd_tx_summaries[i].sapling_nullifiers(),
            zainod_tx_summaries[i].sapling_nullifiers()
        );
    }
}

/// GetTreeState RPC test
pub async fn get_tree_state_by_height(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 5,
        hash: vec![],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_response = zainod_client
        .get_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let lwd_response = lwd_client
        .get_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetTreeState responses...");

    println!("\nZainod response:");
    println!("tree state: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("tree state: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetTreeState RPC test
pub async fn get_tree_state_by_hash(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 5,
        hash: vec![],
    };

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let block = lwd_client.get_block(request).await.unwrap().into_inner();
    let mut block_hash = block.hash().0.to_vec();
    block_hash.reverse();

    let block_id = proto::service::BlockId {
        height: 0,
        hash: block_hash,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_response = zainod_client
        .get_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    let request = tonic::Request::new(block_id.clone());
    let lwd_response = lwd_client
        .get_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetTreeState responses...");

    println!("\nZainod response:");
    println!("tree state: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("tree state: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetTreeState RPC test
pub async fn get_tree_state_out_of_bounds(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let block_id = proto::service::BlockId {
        height: 20,
        hash: vec![],
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let zainod_err_status = zainod_client.get_tree_state(request).await.unwrap_err();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(block_id.clone());
    let lwd_err_status = lwd_client.get_tree_state(request).await.unwrap_err();

    println!("Asserting GetTreeState responses...");

    println!("\nZainod response:");
    println!("error status: {:?}", zainod_err_status);

    println!("\nLightwalletd response:");
    println!("error status: {:?}", lwd_err_status);

    println!();

    assert_eq!(
        zainod_err_status.message(),
        "Error: Height out of range [20]. Height requested is greater than the best chain tip [10].");
    assert_eq!(lwd_err_status.message(), "-8: Block height out of range");
    assert_eq!(zainod_err_status.code(), tonic::Code::OutOfRange);
    assert_eq!(lwd_err_status.code(), tonic::Code::Unknown);
}

/// GetLatestTreeState RPC test
pub async fn get_latest_tree_state(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let zainod_response = zainod_client
        .get_latest_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let lwd_response = lwd_client
        .get_latest_tree_state(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetLatestTreeState responses...");

    println!("\nZainod response:");
    println!("tree state: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("tree state: {:?}", lwd_response);

    println!();

    assert_eq!(zainod_response, lwd_response);
}

/// GetSubtreeRoots RPC test
///
/// This test requires Zebrad testnet/mainnet to be already synced to at least 2 sapling shards with the cache at
/// `CARGO_MANIFEST_DIR/chain_cache/get_subtree_roots_sapling`.
/// `network` should match the network type of the cached chain.
///
/// Example directory tree:
/// ```BASH
/// zcash-local-net/chain_cache/get_subtree_roots_sapling/
/// └── state
///     └── v26
///         └── testnet
///             ├── 000008.sst
///             ├── 000010.sst
/// ```
///
pub async fn get_subtree_roots_sapling(
    zebrad_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
    network: Network,
) {
    if matches!(network, Network::Regtest) {
        panic!("this test fixture requires testnet or mainnet network!");
    }

    let zebrad = Zebrad::launch(ZebradConfig {
        zebrad_bin,
        network_listen_port: None,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: ZEBRAD_DEFAULT_MINER,
        chain_cache: Some(utils::chain_cache_dir().join("get_subtree_roots_sapling")),
        network,
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zebrad.rpc_listen_port(),
        network,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zebrad.config_dir().path().join(config::ZCASHD_FILENAME),
    })
    .unwrap();

    let subtree_roots_arg = proto::service::GetSubtreeRootsArg {
        start_index: 0,
        shielded_protocol: 0,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(subtree_roots_arg);
    let mut zainod_response = zainod_client
        .get_subtree_roots(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_subtree_roots = Vec::new();
    while let Some(subtree_root) = zainod_response.message().await.unwrap() {
        zainod_subtree_roots.push(subtree_root);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(subtree_roots_arg);
    let mut lwd_response = lwd_client
        .get_subtree_roots(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_subtree_roots = Vec::new();
    while let Some(subtree_root) = lwd_response.message().await.unwrap() {
        lwd_subtree_roots.push(subtree_root);
    }

    println!("Asserting GetSubtreeRoots responses...");

    println!("\nZainod response:");
    println!("subtree roots: {:?}", zainod_subtree_roots);

    println!("\nLightwalletd response:");
    println!("subtree roots: {:?}", lwd_subtree_roots);

    println!();

    if lwd_subtree_roots.len() < 2 {
        panic!("please sync testnet chain until there are at least 2 subtree roots");
    }
    assert_eq!(zainod_subtree_roots, lwd_subtree_roots);
}

/// GetSubtreeRoots RPC test
///
/// This test requires Zebrad testnet/mainnet to be already synced to at least 2 orchard shards with the cache at
/// `CARGO_MANIFEST_DIR/chain_cache/get_subtree_roots_orchard`.
/// `network` should match the network type of the cached chain.
///
/// Example directory tree:
///
/// ```BASH
/// zcash-local-net/chain_cache/get_subtree_roots_orchard/
/// └── state
///     └── v26
///         └── testnet
///             ├── 000008.sst
///             ├── 000010.sst
/// ```
///
pub async fn get_subtree_roots_orchard(
    zebrad_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
    network: Network,
) {
    if matches!(network, Network::Regtest) {
        panic!("this test fixture requires testnet or mainnet network!");
    }

    let zebrad = Zebrad::launch(ZebradConfig {
        zebrad_bin,
        network_listen_port: None,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: ZEBRAD_DEFAULT_MINER,
        chain_cache: Some(utils::chain_cache_dir().join("get_subtree_roots_orchard")),
        network,
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zebrad.rpc_listen_port(),
        network,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zebrad.config_dir().path().join(config::ZCASHD_FILENAME),
    })
    .unwrap();

    let subtree_roots_arg = proto::service::GetSubtreeRootsArg {
        start_index: 0,
        shielded_protocol: 1,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(subtree_roots_arg);
    let mut zainod_response = zainod_client
        .get_subtree_roots(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_subtree_roots = Vec::new();
    while let Some(subtree_root) = zainod_response.message().await.unwrap() {
        zainod_subtree_roots.push(subtree_root);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(subtree_roots_arg);
    let mut lwd_response = lwd_client
        .get_subtree_roots(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_subtree_roots = Vec::new();
    while let Some(subtree_root) = lwd_response.message().await.unwrap() {
        lwd_subtree_roots.push(subtree_root);
    }

    println!("Asserting GetSubtreeRoots responses...");

    println!("\nZainod response:");
    println!("subtree roots: {:?}", zainod_subtree_roots);

    println!("\nLightwalletd response:");
    println!("subtree roots: {:?}", lwd_subtree_roots);

    println!();

    if lwd_subtree_roots.len() < 2 {
        panic!("please sync mainnet chain until there are at least 2 subtree roots");
    }
    assert_eq!(zainod_subtree_roots, lwd_subtree_roots);
}

/// GetAddressUtxos RPC test
pub async fn get_address_utxos_all(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 0,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let zainod_response = zainod_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let lwd_response = lwd_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetAddressUtxos responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_response);

    println!();

    assert_eq!(lwd_response.address_utxos.len(), 2);
    assert_eq!(zainod_response, lwd_response);
}

/// GetAddressUtxos RPC test
pub async fn get_address_utxos_lower(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 0,
        max_entries: 1,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let zainod_response = zainod_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let lwd_response = lwd_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetAddressUtxos responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_response);

    println!();

    assert_eq!(lwd_response.address_utxos.len(), 1);
    assert_eq!(lwd_response.address_utxos.first().unwrap().height, 6);
    assert_eq!(zainod_response, lwd_response);
}

/// GetAddressUtxos RPC test
pub async fn get_address_utxos_upper(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 7,
        max_entries: 1,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let zainod_response = zainod_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let lwd_response = lwd_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetAddressUtxos responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_response);

    println!();

    assert_eq!(lwd_response.address_utxos.len(), 1);
    assert_eq!(lwd_response.address_utxos.first().unwrap().height, 7);
    assert_eq!(zainod_response, lwd_response);
}

/// GetAddressUtxos RPC test
pub async fn get_address_utxos_out_of_bounds(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 20,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let zainod_response = zainod_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let lwd_response = lwd_client
        .get_address_utxos(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetAddressUtxos responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_response);

    println!();

    assert_eq!(lwd_response.address_utxos.len(), 0);
    assert_eq!(zainod_response, lwd_response);
}

/// GetAddressUtxosStream RPC test
pub async fn get_address_utxos_stream_all(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 0,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut zainod_response = zainod_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = zainod_response.message().await.unwrap() {
        zainod_address_utxo_replies.push(address_utxo_reply);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut lwd_response = lwd_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = lwd_response.message().await.unwrap() {
        lwd_address_utxo_replies.push(address_utxo_reply);
    }

    println!("Asserting GetAddressUtxosStream responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_address_utxo_replies);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_address_utxo_replies);

    println!();

    assert_eq!(lwd_address_utxo_replies.len(), 2);
    assert_eq!(zainod_address_utxo_replies, lwd_address_utxo_replies);
}

/// GetAddressUtxosStream RPC test
pub async fn get_address_utxos_stream_lower(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 0,
        max_entries: 1,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut zainod_response = zainod_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = zainod_response.message().await.unwrap() {
        zainod_address_utxo_replies.push(address_utxo_reply);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut lwd_response = lwd_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = lwd_response.message().await.unwrap() {
        lwd_address_utxo_replies.push(address_utxo_reply);
    }

    println!("Asserting GetAddressUtxosStream responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_address_utxo_replies);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_address_utxo_replies);

    println!();

    assert_eq!(lwd_address_utxo_replies.len(), 1);
    assert_eq!(lwd_address_utxo_replies.first().unwrap().height, 6);
    assert_eq!(zainod_address_utxo_replies, lwd_address_utxo_replies);
}

/// GetAddressUtxosStream RPC test
pub async fn get_address_utxos_stream_upper(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 7,
        max_entries: 1,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut zainod_response = zainod_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = zainod_response.message().await.unwrap() {
        zainod_address_utxo_replies.push(address_utxo_reply);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut lwd_response = lwd_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = lwd_response.message().await.unwrap() {
        lwd_address_utxo_replies.push(address_utxo_reply);
    }

    println!("Asserting GetAddressUtxosStream responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_address_utxo_replies);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_address_utxo_replies);

    println!();

    assert_eq!(lwd_address_utxo_replies.len(), 1);
    assert_eq!(lwd_address_utxo_replies.first().unwrap().height, 7);
    assert_eq!(zainod_address_utxo_replies, lwd_address_utxo_replies);
}

/// GetAddressUtxosStream RPC test
pub async fn get_address_utxos_stream_out_of_bounds(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_listen_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .await
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
        network: network::Network::Regtest,
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        zcashd_conf: zcashd.config_path(),
    })
    .unwrap();

    let address_utxos_arg = proto::service::GetAddressUtxosArg {
        addresses: vec![
            "tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i".to_string(),
            "tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd".to_string(),
        ],
        start_height: 20,
        max_entries: 0,
    };

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut zainod_response = zainod_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut zainod_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = zainod_response.message().await.unwrap() {
        zainod_address_utxo_replies.push(address_utxo_reply);
    }

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(address_utxos_arg.clone());
    let mut lwd_response = lwd_client
        .get_address_utxos_stream(request)
        .await
        .unwrap()
        .into_inner();
    let mut lwd_address_utxo_replies = Vec::new();
    while let Some(address_utxo_reply) = lwd_response.message().await.unwrap() {
        lwd_address_utxo_replies.push(address_utxo_reply);
    }

    println!("Asserting GetAddressUtxosStream responses...");

    println!("\nZainod response:");
    println!("address utxos replies: {:?}", zainod_address_utxo_replies);

    println!("\nLightwalletd response:");
    println!("address utxos replies: {:?}", lwd_address_utxo_replies);

    println!();

    println!();

    assert_eq!(lwd_address_utxo_replies.len(), 0);
    assert_eq!(zainod_address_utxo_replies, lwd_address_utxo_replies);
}
